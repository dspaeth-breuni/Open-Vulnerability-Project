package io.github.jeremylong.openvulnerability.client.vulncheck;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import io.github.jeremylong.openvulnerability.client.HttpAsyncClientSupplier;
import io.github.jeremylong.openvulnerability.client.PagedDataSource;
import io.github.jeremylong.openvulnerability.client.nvd.CveApiJson20;
import io.github.jeremylong.openvulnerability.client.nvd.DefCveItem;
import io.github.jeremylong.openvulnerability.client.nvd.NvdApiException;
import io.github.jeremylong.openvulnerability.client.nvd.RateLimitedClient;
import org.apache.hc.client5.http.async.methods.SimpleHttpRequest;
import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;
import org.apache.hc.client5.http.async.methods.SimpleRequestBuilder;
import org.apache.hc.client5.http.async.methods.SimpleRequestProducer;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.DefaultHttpRequestRetryStrategy;
import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;
import org.apache.hc.client5.http.impl.async.HttpAsyncClients;
import org.apache.hc.client5.http.impl.routing.SystemDefaultRoutePlanner;
import org.apache.hc.core5.concurrent.FutureCallback;
import org.apache.hc.core5.http.nio.AsyncRequestProducer;
import org.apache.hc.core5.net.URIBuilder;
import org.apache.hc.core5.util.TimeValue;
import org.apache.hc.core5.util.Timeout;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.ProxySelector;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.ZonedDateTime;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.*;

import static java.util.Objects.nonNull;

/**
 * A client for interacting with the VulnCheck CVE API, facilitating the retrieval of vulnerability data
 * from the NVD (National Vulnerability Database). This client implements the {@link PagedDataSource}
 * interface to effectively manage the pagination of CVE (Common Vulnerabilities and Exposures) items.
 *
 * <p>This client provides a straightforward way to access and traverse paginated data, ensuring that
 * large sets of data can be handled efficiently.</p>
 *
 * <h3>OpenAPI Specification</h3>
 * <p>To download the current OpenAPI specification, you can use the following <code>curl</code> command:</p>
 * <pre>{@code
 * curl --request GET \
 *      --url https://api.vulncheck.com/v3/openapi \
 *      --header 'Accept: application/json' \
 *      -o openapi.json
 * }</pre>
 *
 * <h3>Usage Example</h3>
 * <p>To create an instance of this client and retrieve data, follow the example below:</p>
 * <pre>{@code
 * VulnCheckClient client = new VulnCheckClient(apiToken);
 * List<CVEItem> cveItems = client.retrieveCVEItems();
 * // process CVE items here
 * }</pre>
 *
 * <h3>Requirements</h3>
 * <ul>
 * <li>An API token with access permissions for the VulnCheck API.</li>
 * <li>Network access to the VulnCheck API endpoint.</li>
 * </ul>
 *
 * @see PagedDataSource
 * @see <a href="https://api.vulncheck.com/documentation">VulnCheck API Documentation</a>
 */
public class VulnCheckBackupCveClient implements PagedDataSource<DefCveItem> {
    /**
     * Reference to the logger.
     */
    private static final Logger LOG = LoggerFactory.getLogger(VulnCheckBackupCveClient.class);
    /**
     * The default endpoint for the NVD CVE API.
     */
    private final static String DEFAULT_ENDPOINT = "https://api.vulncheck.com/v3/backup/nist-nvd2";

    /**
     * The VulnCheck API key; can be null if a key is not used.
     * See: https://docs.vulncheck.com/api
     * <p>
     * Sign up for a VulnCheck Account (https://vulncheck.com/signin)
     * Log into the VulnCheck Dashboard.
     * Click on the API Sandbox (https://vulncheck.com/api) to explore the VulnCheck indexes that you have permission to access.
     * Generate a token for programmatic API access.
     */
    private final String apiKey;
    /**
     * The NVD API endpoint used to call the NVD CVE API.
     */
    private final String endpoint;

    /**
     * Jackson object mapper.
     */
    private final ObjectMapper objectMapper;

    /**
     * The user agent to append to the default open-vulnerability-client's user-agent string
     */
    private final String userAgent;

    /**
     * The rate limited HTTP client for calling the NVD APIs.
     */
    private CloseableHttpAsyncClient client;

    /**
     * Flag indicating if the first call has been made.
     */
    private boolean firstCall = true;

    /**
     * The total results from the NVD CVE API call.
     */
    private int totalAvailable = -1;
    /**
     * The maximum number of pages to retrieve from the NVD API.
     */
    private final int maxPageCount;

    private final BlockingQueue<Path> fileQueue = new LinkedBlockingQueue<>();
    private Path nextFile;


    int pageCount = 0;

    int maxRetryCount = 10;

    /**
     * The last HTTP Status Code returned by the API.
     */
    private int lastStatusCode = 200;
    /**
     * The last lastModified timestamp from the NVD data processed.
     */
    private ZonedDateTime lastUpdated = null;

    /**
     * The version of the client.
     */
    private String version = "unknown";

    /**
     * Constructs a new VulnCheck CVE API client.
     *
     * @param apiKey             the api key; can be null
     * @param endpoint           the endpoint for the NVD CVE API; if null the default endpoint is used
     * @param delay              the delay in milliseconds between API calls on a single thread.
     * @param maxPageCount       the maximum number of pages to retrieve from the API.
     * @param maxRetryCount      the maximum number of retries for 503 and 429 status code responses.
     * @param httpClientSupplier supplier for custom HTTP clients; if {@code null} a default client will be used
     * @param userAgent          the user agent to append to the default open-vulnerability-client's user-agent string
     */
    VulnCheckBackupCveClient(String apiKey, String endpoint, long delay, int maxPageCount, int maxRetryCount,
                             HttpAsyncClientSupplier httpClientSupplier, String userAgent) {

        this.apiKey = apiKey;
        this.userAgent = userAgent;
        if (endpoint == null) {
            this.endpoint = DEFAULT_ENDPOINT;
        } else {
            this.endpoint = endpoint;
        }

        this.maxPageCount = maxPageCount;
        this.maxRetryCount = maxRetryCount;

        if (httpClientSupplier == null) {
            RequestConfig requestConfig = RequestConfig.custom()
                    .setConnectTimeout(Timeout.ofSeconds(10)) // Connection timeout
                    .setResponseTimeout(Timeout.ofMinutes(10)) // Socket timeout
                    .setConnectionRequestTimeout(Timeout.ofMinutes(10)) // Connection request timeout
                    .build();

            SystemDefaultRoutePlanner planner = new SystemDefaultRoutePlanner(ProxySelector.getDefault());
            client = HttpAsyncClients
                    .custom()
                    .setDefaultRequestConfig(requestConfig)
                    .setRoutePlanner(planner)
                    .setRetryStrategy(new DefaultHttpRequestRetryStrategy(maxRetryCount, TimeValue.ofMilliseconds(delay)))
                    .useSystemProperties()
                    .build();
        } else {
            client = httpClientSupplier.get();
        }

        client.start();

        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());

        try {
            Properties props = new Properties();
            props.load(getClass().getClassLoader().getResourceAsStream("version.properties"));
            version = props.getProperty("version");
        } catch (IOException e) {
            LOG.debug("Error loading version.properties", e);
        }
    }

    @Override
    public void close() {
        if (nonNull(client)) {
            try {
                client.close();
            } catch (Exception ex) {
                LOG.debug("Error closing client during `close`", ex);
            }

            client = null;
        }
    }

    @Override
    public int getTotalAvailable() {
        return totalAvailable;
    }

    @Override
    public int getLastStatusCode() {
        return lastStatusCode;
    }

    @Override
    public boolean hasNext() {
        if (firstCall) {
            return true;
        }

        return nonNull(nextFile) && (!nextFile.equals(ZipResponseConsumer.END_OF_ENTRIES_MARKER)) && (maxPageCount <= 0 || pageCount < maxPageCount);
    }

    @Override
    public Collection<DefCveItem> next() {
        String json;

        if (firstCall) {
            downloadZipFileToTmpFolder();
            firstCall = false;
            getNextFile();
        }

        pageCount++;

        try {
            LOG.debug("Process File: {}", nextFile);
            json = Files.readString(nextFile, StandardCharsets.UTF_8);

            CveApiJson20 current;
            try {
                current = objectMapper.readValue(json, CveApiJson20.class);
            } catch (JsonMappingException e) {
                LOG.debug("Error parsing NVD data", e);
                // Fail fast on JSON parsing errors
                throw new NvdApiException("Failed to parse NVD data", e);
            } catch (JsonProcessingException e) {
                LOG.debug("Error processing NVD data", e);

                throw new NvdApiException("Failed to parse NVD data", e);
            }

            this.totalAvailable = current.getTotalResults();
            lastUpdated = findLastUpdated(lastUpdated, current.getVulnerabilities());

            return current.getVulnerabilities();
        } catch (IOException e) {
            LOG.debug("Error processing NVD data", e);
            throw new NvdApiException("Failed fetch File", e);
        } finally {
            getNextFile();
        }

    }

    private void getNextFile() {
        try {
            LOG.debug("File waiting: {}", fileQueue.size());
            nextFile = fileQueue.poll(30, TimeUnit.SECONDS);
            LOG.debug("Next File: {}", nextFile);
        } catch (InterruptedException e) {
            LOG.debug("Error processing NVD data", e);
            throw new NvdApiException("Failed fetch File", e);
        }
    }

    private void downloadZipFileToTmpFolder() {
        SimpleHttpResponse response;
        try {
            response = getSimpleHttpResponse(0);
        } catch (ExecutionException e) {
            throw new NvdApiException(e);
        }

        if (response.getCode() == 200) {
            LOG.debug("Content-Type Received: {}", response.getContentType());
            String json = new String(response.getBodyBytes(), StandardCharsets.UTF_8);
            LOG.debug("NVD Response: {}", json);

            BackupResponse current;
            try {
                Path tempDirectory = Files.createTempDirectory("cves-unzipped");

                current = objectMapper.readValue(json, BackupResponse.class);
                String downloadUrl = current.getData().getFirst().getUrl();
                ZipResponseConsumer consumer = new ZipResponseConsumer(tempDirectory, fileQueue);
                AsyncRequestProducer producer = SimpleRequestProducer.create(SimpleRequestBuilder.get(downloadUrl).build());

                Future<Path> c = client.execute(producer, consumer, new FutureCallback<Path>() {

                    @Override
                    public void completed(Path result) {

                    }

                    @Override
                    public void failed(Exception ex) {

                    }

                    @Override
                    public void cancelled() {

                    }
                });

                while (fileQueue.size() < 1 && !c.isDone()) {
                    Thread.sleep(500);
                }

            } catch (JsonMappingException e) {
                LOG.debug("Error parsing NVD data", e);
                // Fail fast on JSON parsing errors
                throw new NvdApiException("Failed to parse NVD data", e);
            } catch (JsonProcessingException e) {
                LOG.debug("Error processing NVD data", e);
                // Re-try on what might be temporarily streaming errors
                // return _next(retryCount + 1);
                throw new NvdApiException("Failed to parse NVD data", e);
            } catch (InterruptedException e) {
                throw new NvdApiException(e);
            } catch (IOException e) {
                throw new NvdApiException(e);
            }
        }
    }

    private SimpleHttpResponse getSimpleHttpResponse(int retryCount) throws ExecutionException {
        Future<SimpleHttpResponse> call;
        SimpleHttpResponse response;

        try {
            call = callApi();

            while (!call.isDone()) {
                Thread.sleep(50);
            }

            response = call.get();
        } catch (InterruptedException e) {
            if (retryCount < maxRetryCount) {
                return getSimpleHttpResponse(retryCount + 1);
            } else {
                Thread.currentThread().interrupt();
                close();
                throw new NvdApiException(e);
            }
        }

        return response;
    }

    @Override
    public ZonedDateTime getLastUpdated() {
        return lastUpdated;
    }

    private ZonedDateTime findLastUpdated(ZonedDateTime lastUpdated, List<DefCveItem> vulnerabilities) {
        ZonedDateTime current = lastUpdated;
        for (DefCveItem item : vulnerabilities) {
            if (current == null || current.compareTo(item.getCve().getLastModified()) < 0) {
                current = item.getCve().getLastModified();
            }
        }
        return current;
    }

    /**
     * Asynchronously calls the NVD CVE API.
     *
     * @return the future
     * @throws NvdApiException thrown if there is a problem calling the API
     */
    private Future<SimpleHttpResponse> callApi() throws NvdApiException {
        try {
            URIBuilder uriBuilder = new URIBuilder(endpoint);

            final SimpleRequestBuilder builder = SimpleRequestBuilder.get();

            builder.addHeader("Authorization", "Bearer " + apiKey);
            builder.addHeader("Accept", "application/json");

            String ua = "open-vulnerability-client/" + version;

            if (userAgent != null) {
                ua += "; " + userAgent;
            }

            builder.addHeader("User-Agent", ua);
            URI uri = uriBuilder.build();

            LOG.debug("requesting URI: {}", uri.toString());

            final SimpleHttpRequest request = builder
                    .setUri(uri)
                    .build();

            return client.execute(request, new RateLimitedClient.SimpleFutureResponse());
        } catch (URISyntaxException e) {
            throw new NvdApiException(e);
        }
    }
}
