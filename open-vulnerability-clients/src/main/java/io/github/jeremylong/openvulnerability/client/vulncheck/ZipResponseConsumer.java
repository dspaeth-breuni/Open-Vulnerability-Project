package io.github.jeremylong.openvulnerability.client.vulncheck;

import org.apache.hc.client5.http.async.methods.AbstractBinResponseConsumer;
import org.apache.hc.core5.http.ContentType;
import org.apache.hc.core5.http.HttpResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.BlockingQueue;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static java.util.Objects.nonNull;

// Custom response consumer to process the ZIP input stream
class ZipResponseConsumer extends AbstractBinResponseConsumer<Path> {
    public static final Path END_OF_ENTRIES_MARKER = Path.of("END_OF_ENTRIES");
    private static final Logger LOG = LoggerFactory.getLogger(ZipResponseConsumer.class);

    private PipedOutputStream pipedOutputStream;
    private PipedInputStream pipedInputStream;
    private Thread processingThread;
    private volatile Exception extractionException;
    private final Path tempDir;
    private final BlockingQueue<Path> fileQueue;

    public ZipResponseConsumer(Path tempDir, BlockingQueue<Path> fileQueue) {
        this.tempDir = tempDir;
        this.fileQueue = fileQueue;
    }

    @Override
    protected void start(HttpResponse response, ContentType contentType) throws IOException {
        // Initialize piped streams
        pipedOutputStream = new PipedOutputStream();
        pipedInputStream = new PipedInputStream(pipedOutputStream);

        // Start a new thread to process the input stream
        processingThread = new Thread(() -> {
            try {
                // Process the input stream using ZipInputStream
                try (ZipInputStream zipInputStream = new ZipInputStream(pipedInputStream)) {
                    ZipEntry entry;
                    while ((entry = zipInputStream.getNextEntry()) != null) {
                        // Sanitize entry name to prevent directory traversal attacks
                        String entryName = entry.getName();
                        if (entryName.contains("..") || entryName.startsWith("/")) {
                            LOG.error("Invalid entry name: {}", entryName);
                            continue;
                        }

                        Path filePath = tempDir.resolve(entryName);

                        if (entry.getName().contains("..") || entry.getName().startsWith("/")) {
                            LOG.error("Invalid entry: {}", entry.getName());
                            continue;
                        }

                        if (entry.isDirectory()) {
                            Files.createDirectories(filePath);
                        } else {
                            Files.createDirectories(filePath.getParent());
                            Path decompressedFilePath = filePath.resolveSibling(filePath.getFileName().toString().replace(".gz", ""));

                            LOG.info("Extracting {} to {}", entryName, decompressedFilePath);

                            if (!Files.exists(decompressedFilePath)) {
                                processGzFile(zipInputStream, decompressedFilePath);
                            }

                            fileQueue.put(decompressedFilePath);
                        }

                        zipInputStream.closeEntry();
                    }
                }
                LOG.info("Finished processing zip file");
                // inputstream is closed
                pipedInputStream = null;
            } catch (Exception e) {
                extractionException = e;
            }
        });
        processingThread.start();
    }

    @Override
    protected int capacityIncrement() {
        return 1 * 1024 * 1024;
    }

    @Override
    protected void data(ByteBuffer src, boolean endOfStream) throws IOException {
        if (src.remaining() > 0) {
            try {
                pipedOutputStream.write(src.array(), src.arrayOffset() + src.position(), src.remaining());
            } catch (IOException e) {
                if (!e.getMessage().contains("closed")) {
                    throw e;
                }
            }
        }

        if (endOfStream) {
            LOG.info("Received end of zip file");
        }
    }

    @Override
    protected Path buildResult() {
        // Close the piped output stream to signal end of data
        try {
            if (nonNull(pipedOutputStream)) {
                pipedOutputStream.flush();
                pipedOutputStream.close();
            }

            if (nonNull(pipedInputStream)) {
                pipedInputStream.close();
            }

            pipedInputStream = null;
            pipedOutputStream = null;

            // Wait for the processing thread to finish
            processingThread.join();

            // Check if any exception occurred during extraction
            if (extractionException != null) {
                throw extractionException;
            }

            fileQueue.put(END_OF_ENTRIES_MARKER);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }


        return tempDir;
    }

    @Override
    public void releaseResources() {
        // Close streams and interrupt processing thread if necessary
        try {
            if (pipedOutputStream != null) {
                pipedOutputStream.close();
            }
            if (pipedInputStream != null) {
                pipedInputStream.close();
            }
        } catch (IOException e) {
            // Ignore
        }
        if (processingThread != null && processingThread.isAlive()) {
            processingThread.interrupt();
        }
    }

    static public class NonClosingInputStream extends FilterInputStream {
        public NonClosingInputStream(InputStream in) {
            super(in);
        }

        @Override
        public void close() throws IOException {
            // Do nothing to prevent closing the underlying stream
        }
    }

    private static void processGzFile(InputStream zipInputStream, Path outputFilePath) throws IOException {
        // Use a GZIPInputStream to decompress the .gz file
        try (GZIPInputStream gzipInputStream = new GZIPInputStream(new NonClosingInputStream(zipInputStream))) {
            Files.copy(gzipInputStream, outputFilePath);
        }
    }
}
