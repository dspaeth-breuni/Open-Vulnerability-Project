package io.github.jeremylong.openvulnerability.client.vulncheck;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import io.github.jeremylong.openvulnerability.client.HttpAsyncClientSupplier;
import io.github.jeremylong.openvulnerability.client.PagedDataSource;
import io.github.jeremylong.openvulnerability.client.nvd.CveItem;
import io.github.jeremylong.openvulnerability.client.nvd.DefCveItem;
import io.github.jeremylong.openvulnerability.client.nvd.NvdApiException;
import io.github.jeremylong.openvulnerability.client.nvd.RateLimitedClient;
import org.apache.hc.client5.http.async.methods.SimpleHttpRequest;
import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;
import org.apache.hc.client5.http.async.methods.SimpleRequestBuilder;
import org.apache.hc.client5.http.impl.DefaultHttpRequestRetryStrategy;
import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;
import org.apache.hc.client5.http.impl.async.HttpAsyncClients;
import org.apache.hc.client5.http.impl.routing.SystemDefaultRoutePlanner;
import org.apache.hc.core5.http.Header;
import org.apache.hc.core5.http.NameValuePair;
import org.apache.hc.core5.net.URIBuilder;
import org.apache.hc.core5.util.TimeValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.ProxySelector;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.time.ZonedDateTime;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

import static java.util.Objects.nonNull;

/**
 * A client for interacting with the VulnCheck CVE API, facilitating the retrieval of vulnerability data
 * from the NVD (National Vulnerability Database). This client implements the {@link PagedDataSource}
 * interface to effectively manage the pagination of CVE (Common Vulnerabilities and Exposures) items.
 *
 * <p>This client provides a straightforward way to access and traverse paginated data, ensuring that
 * large sets of data can be handled efficiently.</p>
 *
 * <h3>OpenAPI Specification</h3>
 * <p>To download the current OpenAPI specification, you can use the following <code>curl</code> command:</p>
 * <pre>{@code
 * curl --request GET \
 *      --url https://api.vulncheck.com/v3/openapi \
 *      --header 'Accept: application/json' \
 *      -o openapi.json
 * }</pre>
 *
 * <h3>Usage Example</h3>
 * <p>To create an instance of this client and retrieve data, follow the example below:</p>
 * <pre>{@code
 * VulnCheckClient client = new VulnCheckClient(apiToken);
 * List<CVEItem> cveItems = client.retrieveCVEItems();
 * // process CVE items here
 * }</pre>
 *
 * <h3>Requirements</h3>
 * <ul>
 * <li>An API token with access permissions for the VulnCheck API.</li>
 * <li>Network access to the VulnCheck API endpoint.</li>
 * </ul>
 *
 * @see PagedDataSource
 * @see <a href="https://api.vulncheck.com/documentation">VulnCheck API Documentation</a>
 */
public class VulnCheckCveClient implements PagedDataSource<DefCveItem> {
    /**
     * Reference to the logger.
     */
    private static final Logger LOG = LoggerFactory.getLogger(VulnCheckCveClient.class);
    /**
     * The default endpoint for the NVD CVE API.
     */
    private final static String DEFAULT_ENDPOINT = "https://api.vulncheck.com/v3/index/nist-nvd2";

    /**
     * The VulnCheck API key; can be null if a key is not used.
     * See: https://docs.vulncheck.com/api
     * <p>
     * Sign up for a VulnCheck Account (https://vulncheck.com/signin)
     * Log into the VulnCheck Dashboard.
     * Click on the API Sandbox (https://vulncheck.com/api) to explore the VulnCheck indexes that you have permission to access.
     * Generate a token for programmatic API access.
     */
    private final String apiKey;
    /**
     * The NVD API endpoint used to call the NVD CVE API.
     */
    private final String endpoint;

    /**
     * Jackson object mapper.
     */
    private final ObjectMapper objectMapper;

    /**
     * The user agent to append to the default open-vulnerability-client's user-agent string
     */
    private final String userAgent;

    /**
     * The rate limited HTTP client for calling the NVD APIs.
     */
    private CloseableHttpAsyncClient client;

    /**
     * Flag indicating if the first call has been made.
     */
    private boolean firstCall = true;

    /**
     * Represents the cursor used for pagination in the VulnCheck CVE API client.
     * This cursor points to the next set of results to be retrieved from the API.
     * It is initially set to {@code null} and will be updated as more pages are fetched.
     */
    private String nextCursor = null;

    /**
     * The number of results per page.
     */
    private int resultsPerPage = 10;
    /**
     * The total results from the NVD CVE API call.
     */
    private int totalAvailable = -1;
    /**
     * The maximum number of pages to retrieve from the NVD API.
     */
    private final int maxPageCount;

    int pageCount = 0;

    int maxRetryCount = 10;

    /**
     * A list of filters to apply to the request.
     */
    private List<NameValuePair> filters;
    /**
     * The last HTTP Status Code returned by the API.
     */
    private int lastStatusCode = 200;
    /**
     * The last lastModified timestamp from the NVD data processed.
     */
    private ZonedDateTime lastUpdated = null;

    /**
     * The version of the client.
     */
    private String version = "unknown";

    /**
     * Constructs a new VulnCheck CVE API client.
     *
     * @param apiKey             the api key; can be null
     * @param endpoint           the endpoint for the NVD CVE API; if null the default endpoint is used
     * @param delay              the delay in milliseconds between API calls on a single thread.
     * @param maxPageCount       the maximum number of pages to retrieve from the API.
     * @param maxRetryCount      the maximum number of retries for 503 and 429 status code responses.
     * @param httpClientSupplier supplier for custom HTTP clients; if {@code null} a default client will be used
     * @param userAgent          the user agent to append to the default open-vulnerability-client's user-agent string
     */
    VulnCheckCveClient(String apiKey, String endpoint, long delay, int maxPageCount, int maxRetryCount,
                       HttpAsyncClientSupplier httpClientSupplier, String userAgent) {

        this.apiKey = apiKey;
        this.userAgent = userAgent;
        if (endpoint == null) {
            this.endpoint = DEFAULT_ENDPOINT;
        } else {
            this.endpoint = endpoint;
        }

        this.maxPageCount = maxPageCount;
        this.maxRetryCount = maxRetryCount;

        if (httpClientSupplier == null) {
            SystemDefaultRoutePlanner planner = new SystemDefaultRoutePlanner(ProxySelector.getDefault());
            client = HttpAsyncClients
                    .custom()
                    .setRoutePlanner(planner)
                    .setRetryStrategy(new DefaultHttpRequestRetryStrategy(maxRetryCount, TimeValue.ofMilliseconds(delay)))
                    .useSystemProperties()
                    .build();
        } else {
            client = httpClientSupplier.get();
        }

        client.start();

        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());

        try {
            Properties props = new Properties();
            props.load(getClass().getClassLoader().getResourceAsStream("version.properties"));
            version = props.getProperty("version");
        } catch (IOException e) {
            LOG.debug("Error loading version.properties", e);
        }
    }

    @Override
    public void close() {
        if (nonNull(client)) {
            try {
                client.close();
            } catch (Exception ex) {
                LOG.debug("Error closing client during `close`", ex);
            }

            client = null;
        }
    }

    @Override
    public int getTotalAvailable() {
        return totalAvailable;
    }

    @Override
    public int getLastStatusCode() {
        return lastStatusCode;
    }

    @Override
    public boolean hasNext() {
        if (firstCall) {
            return true;
        }

        return nonNull(nextCursor) && (maxPageCount <= 0 || pageCount < maxPageCount);
    }

    @Override
    public Collection<DefCveItem> next() {
        String json;
        Future<SimpleHttpResponse> call;

        pageCount++;

        try {
            SimpleHttpResponse response = getSimpleHttpResponse(0);

            if (response.getCode() == 200) {
                LOG.debug("Content-Type Received: {}", response.getContentType());
                json = new String(response.getBodyBytes(), StandardCharsets.UTF_8);
                LOG.debug("NVD Response: {}", json);

                CveApiJsonVulnCheck current;
                try {
                    current = objectMapper.readValue(json, CveApiJsonVulnCheck.class);
                } catch (JsonMappingException e) {
                    LOG.debug("Error parsing NVD data", e);
                    // Fail fast on JSON parsing errors
                    throw new NvdApiException("Failed to parse NVD data", e);
                } catch (JsonProcessingException e) {
                    LOG.debug("Error processing NVD data", e);
                    // Re-try on what might be temporarily streaming errors
                    // return _next(retryCount + 1);
                    throw new NvdApiException("Failed to parse NVD data", e);
                }
                this.totalAvailable = current.getMeta().getTotalDocuments();
                lastUpdated = findLastUpdated(lastUpdated, current.getVulnerabilities());
                if (firstCall) {
                    firstCall = false;
                    nextCursor = current.getMeta().getNextCursor();
                }

                return current.getVulnerabilities().stream().map(DefCveItem::new).collect(Collectors.toList());
            } else {
                lastStatusCode = response.getCode();
                LOG.debug("Status Code: {}", lastStatusCode);
                LOG.debug("Reason: {}", response.getReasonPhrase());
                LOG.debug("Response Headers:");
                Header[] headers = response.getHeaders();

                for (Header header : headers) {
                    LOG.debug("Key : " + header.getName() + " ,Value : " + header.getValue());
                }

                json = new String(response.getBodyBytes(), StandardCharsets.UTF_8);

                LOG.debug("Response: {}", response);

                ApiErrorResponse errorResponse;

                try {
                    errorResponse = objectMapper.readValue(json, ApiErrorResponse.class);
                } catch (JsonMappingException e) {
                    LOG.debug("Error parsing NVD data", e);
                    // Fail fast on JSON parsing errors
                    throw new NvdApiException("Failed to parse NVD data", e);
                } catch (JsonProcessingException e) {
                    LOG.debug("Error processing NVD data", e);
                    // Re-try on what might be temporarily streaming errors
                    // return _next(retryCount + 1);
                    throw new NvdApiException("Failed to parse NVD data", e);
                }

                if (errorResponse.getErrors() != null && errorResponse.getErrors().size() > 0) {
                    if (lastStatusCode == 401 || lastStatusCode == 403) {
                        if (this.apiKey.length() > 30) {
                            String masked = String.format("Invalid API Key: %s-*****-%s",
                                    this.apiKey.substring(0, 5),
                                    this.apiKey.substring(this.apiKey.length() - 5, this.apiKey.length()));
                            throw new NvdApiException(masked);
                        }
                        String masked = String.format("Invalid API Key: %s-*****", this.apiKey.substring(0, 5));
                        throw new NvdApiException(masked);
                    }
                    throw new NvdApiException("NVD Returned Status Code: " + lastStatusCode + " - " + errorResponse.getErrorString());
                }
                throw new NvdApiException("NVD Returned Status Code: " + lastStatusCode);
            }
        } catch (ExecutionException e) {
            // in rare cases we get an error from the NVD - log the error and only fail if we retry too many times
            LOG.debug("Error retrieving the NVD data", e);
            close();
            throw new NvdApiException(e);
        }
    }

    private SimpleHttpResponse getSimpleHttpResponse(int retryCount) throws ExecutionException {
        Future<SimpleHttpResponse> call;
        SimpleHttpResponse response;

        try {
            call = callApi(nextCursor);

            while (!call.isDone()) {
                Thread.sleep(50);
            }

            response = call.get();
        } catch (InterruptedException e) {
            if (retryCount < maxRetryCount) {
                return getSimpleHttpResponse(retryCount + 1);
            } else {
                Thread.currentThread().interrupt();
                close();
                throw new NvdApiException(e);
            }
        }

        return response;
    }

    @Override
    public ZonedDateTime getLastUpdated() {
        return lastUpdated;
    }

    /**
     * Set the filter parameters for the CVE API calls.
     *
     * @param filters the list of parameters used to filter the results in the API call
     */
    void setFilters(List<NameValuePair> filters) {
        this.filters = filters;
    }

    /**
     * The number of results per page; the default is 2000.
     *
     * @param resultsPerPage the number of results per page
     */
    void setResultsPerPage(int resultsPerPage) {
        this.resultsPerPage = resultsPerPage;
    }

    private ZonedDateTime findLastUpdated(ZonedDateTime lastUpdated, List<CveItem> vulnerabilities) {
        ZonedDateTime current = lastUpdated;
        for (CveItem item : vulnerabilities) {
            if (current == null || current.compareTo(item.getLastModified()) < 0) {
                current = item.getLastModified();
            }
        }
        return current;
    }

    /**
     * Asynchronously calls the NVD CVE API.
     *
     * @param startIndex the start index to request
     * @return the future
     * @throws NvdApiException thrown if there is a problem calling the API
     */
    private Future<SimpleHttpResponse> callApi(String startIndex) throws NvdApiException {
        try {
            URIBuilder uriBuilder = new URIBuilder(endpoint);
            if (filters != null) {
                uriBuilder.addParameters(filters);
            }
            uriBuilder.addParameter("limit", Integer.toString(resultsPerPage));

            if (nonNull(startIndex)) {
                uriBuilder.addParameter("cursor", startIndex);
            } else {
                uriBuilder.addParameter("start_cursor", startIndex);
            }
            final SimpleRequestBuilder builder = SimpleRequestBuilder.get();

            builder.addHeader("Authorization", "Bearer " + apiKey);
            builder.addHeader("Accept", "application/json");

            String ua = "open-vulnerability-client/" + version;

            if (userAgent != null) {
                ua += "; " + userAgent;
            }

            builder.addHeader("User-Agent", ua);
            URI uri = uriBuilder.build();

            LOG.debug("requesting URI: {}", uri.toString());

            final SimpleHttpRequest request = builder
                    .setUri(uri)
                    .build();

            return client.execute(request, new RateLimitedClient.SimpleFutureResponse());
        } catch (URISyntaxException e) {
            throw new NvdApiException(e);
        }
    }
}
